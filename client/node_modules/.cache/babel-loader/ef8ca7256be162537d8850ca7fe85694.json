{"ast":null,"code":"import API from '../../utils/API';\nimport Moment from 'moment';\nMoment.locale('fr');\n\nvar cluster_dates = function cluster_dates(traffic, date_low, date_high) {\n  return traffic.filter(function (l) {\n    return new Date(l.created_at).getTime() > date_low.getTime() && new Date(l.created_at).getTime() <= date_high.getTime();\n  });\n};\n\nvar get_filtered_events = function get_filtered_events(query, sort, numElements) {\n  return new Promise(function (resolve, reject) {\n    API.get_event(query, sort).then(function (data) {\n      var traffic = data.data.data;\n\n      if (traffic.length > 0) {\n        var date_min = new Date(traffic[0].created_at);\n        date_min.setTime(date_min.getTime() - 1);\n        var date_max = new Date(traffic[traffic.length - 1].created_at);\n        var date_array = [],\n            traffic_data = [],\n            dummy_date = null;\n\n        for (var i = 0; i <= numElements; i++) {\n          var intermDate = new Date(date_min.getTime() + i * (date_max.getTime() - date_min.getTime()) / numElements);\n          date_array.push(Moment(intermDate).format('HH:mm:ss'));\n\n          if (i > 0) {\n            var trafficInWindow = cluster_dates(traffic, dummy_date, intermDate);\n            traffic_data.push(trafficInWindow.length);\n          }\n\n          dummy_date = intermDate;\n        }\n\n        resolve({\n          traffic_data: traffic_data,\n          date_array: date_array,\n          max_traffic: Math.max.apply(Math, traffic_data)\n        });\n      }\n    }, function (error) {\n      reject('Erreur');\n    });\n  });\n};\n\nexport { get_filtered_events };","map":{"version":3,"sources":["/Users/tonyparker/Documents/github/karfur/client/src/components/Functions/APIFunctions.js"],"names":["API","Moment","locale","cluster_dates","traffic","date_low","date_high","filter","l","Date","created_at","getTime","get_filtered_events","query","sort","numElements","Promise","resolve","reject","get_event","then","data","length","date_min","setTime","date_max","date_array","traffic_data","dummy_date","i","intermDate","push","format","trafficInWindow","max_traffic","Math","max","error"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,iBAAhB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AAEAA,MAAM,CAACC,MAAP,CAAc,IAAd;;AAEA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,OAAD,EAAUC,QAAV,EAAoBC,SAApB,EAAkC;AACtD,SAAOF,OAAO,CAACG,MAAR,CAAe,UAAAC,CAAC,EAAI;AACzB,WAAQ,IAAIC,IAAJ,CAASD,CAAC,CAACE,UAAX,CAAD,CAAyBC,OAAzB,KAAqCN,QAAQ,CAACM,OAAT,EAArC,IAA4D,IAAIF,IAAJ,CAASD,CAAC,CAACE,UAAX,CAAD,CAAyBC,OAAzB,MAAoCL,SAAS,CAACK,OAAV,EAAtG;AACD,GAFM,CAAP;AAGD,CAJD;;AAMA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,KAAD,EAAQC,IAAR,EAAcC,WAAd,EAA8B;AACxD,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtClB,IAAAA,GAAG,CAACmB,SAAJ,CAAcN,KAAd,EAAqBC,IAArB,EAA2BM,IAA3B,CAAgC,UAACC,IAAD,EAAU;AACxC,UAAIjB,OAAO,GAACiB,IAAI,CAACA,IAAL,CAAUA,IAAtB;;AACA,UAAGjB,OAAO,CAACkB,MAAR,GAAe,CAAlB,EAAoB;AAClB,YAAIC,QAAQ,GAAC,IAAId,IAAJ,CAASL,OAAO,CAAC,CAAD,CAAP,CAAWM,UAApB,CAAb;AACAa,QAAAA,QAAQ,CAACC,OAAT,CAAiBD,QAAQ,CAACZ,OAAT,KAAqB,CAAtC;AACA,YAAIc,QAAQ,GAAC,IAAIhB,IAAJ,CAASL,OAAO,CAACA,OAAO,CAACkB,MAAR,GAAe,CAAhB,CAAP,CAA0BZ,UAAnC,CAAb;AAEA,YAAIgB,UAAU,GAAG,EAAjB;AAAA,YACEC,YAAY,GAAG,EADjB;AAAA,YAEEC,UAAU,GAAC,IAFb;;AAGA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAId,WAArB,EAAkCc,CAAC,EAAnC,EAAuC;AACrC,cAAIC,UAAU,GAAG,IAAIrB,IAAJ,CAASc,QAAQ,CAACZ,OAAT,KAAqBkB,CAAC,IAAIJ,QAAQ,CAACd,OAAT,KAAqBY,QAAQ,CAACZ,OAAT,EAAzB,CAAD,GAAgDI,WAA9E,CAAjB;AACAW,UAAAA,UAAU,CAACK,IAAX,CAAiB9B,MAAM,CAAC6B,UAAD,CAAN,CAAmBE,MAAnB,CAA0B,UAA1B,CAAjB;;AAEA,cAAGH,CAAC,GAAC,CAAL,EAAO;AACL,gBAAII,eAAe,GAAG9B,aAAa,CAACC,OAAD,EAAUwB,UAAV,EAAsBE,UAAtB,CAAnC;AACAH,YAAAA,YAAY,CAACI,IAAb,CAAkBE,eAAe,CAACX,MAAlC;AACD;;AACDM,UAAAA,UAAU,GAACE,UAAX;AACD;;AAEDb,QAAAA,OAAO,CAAC;AACNU,UAAAA,YAAY,EAAEA,YADR;AAEND,UAAAA,UAAU,EAAGA,UAFP;AAGNQ,UAAAA,WAAW,EAAEC,IAAI,CAACC,GAAL,OAAAD,IAAI,EAAQR,YAAR;AAHX,SAAD,CAAP;AAKD;AACF,KA3BD,EA2BG,UAACU,KAAD,EAAW;AACZnB,MAAAA,MAAM,CAAC,QAAD,CAAN;AACD,KA7BD;AA8BD,GA/BM,CAAP;AAgCD,CAjCD;;AAmCA,SAAQN,mBAAR","sourcesContent":["import API from '../../utils/API';\nimport Moment from 'moment';\n\nMoment.locale('fr');\n\nconst cluster_dates = (traffic, date_low, date_high) => {\n  return traffic.filter(l => {\n    return (new Date(l.created_at)).getTime() > date_low.getTime() && (new Date(l.created_at)).getTime()<=date_high.getTime();\n  });\n}\n\nconst get_filtered_events = (query, sort, numElements) => {\n  return new Promise((resolve, reject) => {\n    API.get_event(query, sort).then((data) => {\n      let traffic=data.data.data;\n      if(traffic.length>0){\n        let date_min=new Date(traffic[0].created_at) ;\n        date_min.setTime(date_min.getTime() - 1);\n        let date_max=new Date(traffic[traffic.length-1].created_at);\n\n        var date_array = [],\n          traffic_data = [],\n          dummy_date=null;\n        for (var i = 0; i <= numElements; i++) {\n          var intermDate = new Date(date_min.getTime() + i * (date_max.getTime() - date_min.getTime()) / numElements );\n          date_array.push( Moment(intermDate).format('HH:mm:ss') );\n\n          if(i>0){\n            let trafficInWindow = cluster_dates(traffic, dummy_date, intermDate)\n            traffic_data.push(trafficInWindow.length);\n          }\n          dummy_date=intermDate;\n        }\n        \n        resolve({\n          traffic_data: traffic_data,\n          date_array : date_array,\n          max_traffic: Math.max(...traffic_data)\n        })\n      }\n    }, (error) => {\n      reject('Erreur')\n    })\n  })\n}\n\nexport {get_filtered_events};"]},"metadata":{},"sourceType":"module"}